from entity import Entity, Player, Roach, Bullet
from utilities import *
from settings import *
import pygame, sys
import json
import math
import pente as pente
from icecream import ic

class Entities:
    """
    This class handles and updates all entities.
    """

    def __init__(self):
        self.entity_tiles = {} #for entities
        self.weapon_tiles = {} #for bullets and guns
        self.enemy_hitbox = [] #for hitboxes generated by enemies
        self.player_hitbox = [] #for hitboxes generated by the player
        self.player = Player((SCREEN_WIDTH // 3 // 2, SCREEN_HEIGHT // 3 // 2), (7, 8), 'skele-right') #initializes player\
        self.entities_in_game = [Roach((128, 128), (8, 8), 'roach'), Roach((128, 128), (8, 8), 'roach'), Roach((128, 128), (8, 8), 'roach'), Roach((128, 128), (8, 8), 'roach'), Roach((128, 128), (8, 8), 'roach'), Roach((128, 128), (8, 8), 'roach'), Roach((128, 128), (8, 8), 'roach'), Roach((128, 128), (8, 8), 'roach'), Roach((128, 128), (8, 8), 'roach')]
        
    
    def update(self, tilemap:dict, offset, target, angle): #returns
        
        self.entity_tiles.clear()
        self.weapon_tiles.clear()
        self.enemy_hitbox.clear()
        self.player_hitbox.clear()
        

        for entity in self.entities_in_game:
            entity.update_entity(tilemap, self.entity_tiles, offset, target)
            
            hitbox = entity.generate_hitbox(offset)
            self.enemy_hitbox.append(hitbox)
            
            if entity.is_dead():
                self.entities_in_game.remove(entity)
                
        for hitbox in self.enemy_hitbox:
            player_hitbox = self.player.generate_hitbox(offset)
            
            if player_hitbox.colliderect(hitbox):
                self.player.damage(1)
                print('Player took a hit')
                
        if DEBUG:
            for entity in self.entities_in_game:
                debug_hitbox = entity.generate_hitbox(offset)
                self.enemy_hitbox.append(debug_hitbox)
            player_hitbox = self.player.generate_hitbox(offset)
        
            self.player_hitbox.append(player_hitbox)
            
        self.player.update_player(tilemap, self.entity_tiles, offset, angle)
        
        return self.entity_tiles #return {'x;y':{'name':player, 'location':(x, y)}}

    def get_weapon_tiles(self):
        return self.weapon_tiles
class Crosshair:
    
    def __init__(self):
        self.name = 'aimer'
        pygame.mouse.set_visible(False)
        pygame.mouse.set_pos((SCREEN_WIDTH // 3 // 2, SCREEN_HEIGHT // 3 // 2))
        self.size = (5, 5)
        self.position = (0, 0)
        
    def set_crosshair(self, name:str, size:tuple): #sets crosshair image.
        self.name = name
        self.size = size
        
    def generate_hitbox(self):
        return pygame.Rect(self.position[0], self.position[1], self.size[0], self.size[1])
    
    def set_mous_position(self, postion:tuple):
        pygame.mouse.set_pos(postion)
        

    def update(self):
            # print("Y postion changed", self.current_position)
        self.position = pygame.mouse.get_pos()
        string_position = str(self.position[0]) + ';' + str(self.position[1])
        return {string_position : {'name':self.name, 'location':self.position}}
    
    

class Frame:
    """_summary_
    Handles every frame.
    """
    
    def __init__(self, levels):
        
        self.tilemap = levels.level_1() #initiates level.
        self.crosshair = Crosshair() #Crosshair handling class
        self.entities = Entities() #Entity handling class
        self.crosshair.set_crosshair('pointer', (5, 5))
        self.menu_open = True
        self.mouse_click = False
        self.tiles_to_render = {}
        self.offset = [0, 0]
        self.render_order = ['tile_map', 'entity', 'crosshair'] #{'backround', 'water', 'floor', 'trap', 'decor', 'wall', 'entity', 'effect', 'particles', 'crosshair'}
        
        self.assets = { #images that have to be loaded per blit of an image
            ##########PLAYER##########
            'skele-right': load_image('sprites/entities/skele/skele-right.png'),
            'skele-left': load_image('sprites/entities/skele/skele-left.png'),
            'skele-dead': load_image('sprites/entities/skele/skele-dead.png'),
            'skele-right-back': load_image('sprites/entities/skele/skele-right-back.png'),
            'skele-left-back': load_image('sprites/entities/skele/skele-left-back.png'),
            ##########ENTITIES##########
            'larry': load_image('sprites/Green_man.png'),
            'player':load_image('sprites/entities/roach/roach.png'),
            'roach': load_image('sprites/entities/roach/roach.png'),
            ##########WEAPONS##########
            'basic_spell':load_image('sprites/weapons/basic_spell.png'),
            'fire_ball':load_image('sprites/weapons/fire_ball.png'),
            ##########TILES##########
            'ground' : load_image('sprites/tiles/floor.png'),
            'aqua_tile': load_images('sprites/tiles/aqua_tile/'),
            ##########CURSOR##########
            'aimer': load_image('sprites/crosshairs/aimer.png'),
            'pointer':load_image('sprites/crosshairs/pointer.png'),
            ##########UI##########
            'menu':load_image('sprites/ui/menu.png'),
            'resume_button':load_image('sprites/ui/resume_button.png'),
            'resume_button_hover':load_image('sprites/ui/resume_button_hover.png'),
            'quit_button':load_image('sprites/ui/quit_button.png'),
            'quit_button_hover':load_image('sprites/ui/quit_button_hover.png'),
            'pente_button':load_image('sprites/ui/pente_button.png'),
            'pente_button_hover':load_image('sprites/ui/pente_button_hover.png'),
            ##########MISC##########
            
            
            
        }
        
        self.crosshair.set_mous_position((0, 0))
        
        with open('debug/current_tilemap.json', 'w') as tilemap_file:
            json.dump(self.tilemap, tilemap_file)

    
    def offset_tiles(self, offset:list, storage):

        for coordinate_index in storage:
            coordinate = list_coordinate(coordinate_index)
            coordinate[0] += offset[0]
            coordinate[1] += offset[1]
            storage[coordinate_index]['location'] = tuple(coordinate)

    # def get_screen_center(self, surface) -> tuple:
    #     mouse_postion = pygame.mouse.get_pos()
    #     # screen_center = ((((self.entities.player.generate_hitbox().centerx - surface.get_height() / 2 - self.offset[0]) / 10) ** 2 + (mouse_postion[0] / 30) ** 2) ** 0.5 / 2, (((self.entities.player.generate_hitbox().centery - surface.get_height() / 2 - self.offset[1]) / 10) ** 2 + (mouse_postion[1] / 30) ** 2) ** 0.5 / 2) 
    #     screen_center = (((self.entities.player.generate_hitbox().centerx - surface.get_width() / 2 - self.offset[0]) / 20) + mouse_postion[0] / 40, ((self.entities.player.generate_hitbox().centery - surface.get_height() / 2 - self.offset[1]) / 20) + mouse_postion[1] / 40)
    #     return screen_center
    
    def get_player_position(self, surface):
        return ((self.entities.player.generate_collision_box().centerx - surface.get_width() / 2 - self.offset[0]) / 20, (self.entities.player.generate_collision_box().centery - surface.get_height() / 2 - self.offset[1]) / 20)
    
    def get_mouse_angle(self):
        player_x_position, player_y_position = (SCREEN_WIDTH // 3 // 2, SCREEN_HEIGHT // 3 // 2)
        mouse_position = pygame.mouse.get_pos()
        
        opposite = -float(mouse_position[1] - player_y_position)
        adjacent = float(mouse_position[0] - player_x_position)
        change1 = -1 if opposite < 0 else 1
        
        # ic(adjacent, opposite)
        hypotenuse =  math.sqrt((opposite ** 2) + (adjacent ** 2))

        
        # angle = math.degrees(math.asin(opposite/hypotenuse))
        
        angle = change1 * math.degrees(math.acos((adjacent/hypotenuse))) if hypotenuse != 0 else 0
        # angle = -math.degrees(math.acos(adjacent/hypotenuse))

        # print("Angle:", angle)
        return angle
    
        
    def update(self, surface):
        self.tiles_to_render.clear()
        if self.menu_open:
            self.tiles_to_render['crosshair'] = self.crosshair.update()
            self.tiles_to_render['tile_map'] = self.tilemap
            
        else:
            screen_center = self.get_player_position(surface)
            self.offset[0] = round(- screen_center[0] * 10)
            self.offset[1] = round(- screen_center[1] * 10)
            #####OFFSET#####
            self.offset_tiles(self.offset, self.tilemap)
            #####UPDATE ENTITIES#####
            self.tiles_to_render['tile_map'] = self.tilemap
            self.tiles_to_render['entity'] = self.entities.update(self.tilemap, tuple(self.offset), screen_center, self.get_mouse_angle())
            self.tiles_to_render['crosshair'] = self.crosshair.update()

    def render(self, surface):
        """_summary_
        This is responsible for pasting images to the screen every frame.
        Args:
            surface (_type_): This is the screen or place where the images are to be blitted.
        """
        self.update(surface)
        
        if self.menu_open:
            for string_coordinate in self.tiles_to_render['tile_map']:
                if self.tiles_to_render['tile_map'][string_coordinate]['name'] in directional_tile:
                    surface.blit(self.assets[self.tiles_to_render['tile_map'][string_coordinate]['name']][int(self.tiles_to_render['tile_map'][string_coordinate]['variant'])], self.tiles_to_render['tile_map'][string_coordinate]['location'])

                else:
                    surface.blit(self.assets[self.tiles_to_render['tile_map'][string_coordinate]['name']], self.tiles_to_render['tile_map'][string_coordinate]['location'])         
            draw_rect_alpha(surface, (0, 0, 0, 150), (0, 0, 1000, 1000))
            surface.blit(self.assets['menu'], (0, 0))
            surface.blit(self.assets['resume_button'], (0, 0))
            surface.blit(self.assets['quit_button'], (0, 0))
            surface.blit(self.assets['pente_button'], (0, 0))
            
            if DEBUG:
                draw_rect_alpha(surface, (0, 0, 255, 100), (160, 144, 33, 16))
                draw_rect_alpha(surface, (0, 0, 255, 100), (208, 144, 33, 16))
                draw_rect_alpha(surface, (0, 0, 255, 100), (256, 144, 33, 16))
              
            quit_button_hitbox = pygame.Rect(208, 144, 33, 16)
            resume_button_hitbox = pygame.Rect(160, 144, 33, 16)
            pente_button_hitbox = pygame.Rect(256, 144, 33, 16)
            mouse_hitbox = self.crosshair.generate_hitbox()
            if pente_button_hitbox.colliderect(mouse_hitbox):
                surface.blit(self.assets['pente_button_hover'], (0, 0))
                if self.mouse_click:
                    pente.main()
                    
            if quit_button_hitbox.colliderect(mouse_hitbox):
                surface.blit(self.assets['quit_button_hover'], (0, 0))
                if self.mouse_click:
                    pygame.quit()
                    sys.exit()
            if resume_button_hitbox.colliderect(mouse_hitbox):
                surface.blit(self.assets['resume_button_hover'], (0, 0))
                if self.mouse_click:
                    self.menu_open = False
                    self.crosshair.set_crosshair('aimer', (5, 5))

                
            cursor_dictionary = self.tiles_to_render['crosshair']
            
            for value in cursor_dictionary.values():
                surface.blit(self.assets[value['name']], value['location'])
                
            # surface.blit(self.assets[self.tiles_to_render])            
        else:
            
            for order in self.render_order:
                
                if order == 'tile_map':
                    for string_coordinate in self.tiles_to_render['tile_map']:
                        if self.tiles_to_render['tile_map'][string_coordinate]['name'] in directional_tile:
                            surface.blit(self.assets[self.tiles_to_render[order][string_coordinate]['name']][int(self.tiles_to_render[order][string_coordinate]['variant'])], self.tiles_to_render[order][string_coordinate]['location'])

                        else:
                            surface.blit(self.assets[self.tiles_to_render[order][string_coordinate]['name']], self.tiles_to_render[order][string_coordinate]['location'])
                else:
                    for string_coordinate in self.tiles_to_render[order]:
                        
                        location = self.tiles_to_render[order][string_coordinate]['location']
                        image = self.assets[self.tiles_to_render[order][string_coordinate]['name']]
                        
                        if 'angle' in self.tiles_to_render[order][string_coordinate]:
                            angle = self.tiles_to_render[order][string_coordinate]['angle']
                            blitRotateCenter(surface, image, location, angle)
                        else:
                            surface.blit(image, location)
        if DEBUG:
            for hitbox in self.entities.enemy_hitbox:
                
                draw_rect_alpha(surface, (255, 0, 0, 100), hitbox)
                
            draw_rect_alpha(surface, (0, 255, 0, 100), self.entities.player_hitbox[0])
            
                
